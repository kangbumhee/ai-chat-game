<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>대화 게임</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Verdana', sans-serif;
        }
        #game-container {
            position: relative;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            overflow: hidden;
        }
        #renderDiv {
            position: relative;
        }
        .info-banner {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 10000;
            max-width: 80%;
            text-align: center;
        }
        .info-banner a {
            color: #4ECDC4;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="info-banner">
            AI 대화 게임 - 캐릭터와 대화를 나눠보세요!
        </div>
        <div id="renderDiv"></div>
    </div>

    <!-- Phaser 라이브러리 -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    
    <script>
// ChatManager - AI 대화 관리 클래스
class ChatManager {
    constructor(systemPrompt) {
        this.systemPrompt = systemPrompt;
        this.messages = [];
        // API 키는 기본값으로 설정됨
        this.apiKey = 'KWLdoSWO91FIGXV6GXXycpmCA02cS8KQ';
    }

    addMessage(role, content) {
        this.messages.push({ role, content });
    }

    getLastMessage() {
        return this.messages.length > 0 ? this.messages[this.messages.length - 1] : null;
    }

    async getCharacterResponse(model = 'mistral-small-latest') {
        try {
            // Mistral API 호출
            const response = await this.callMistralAPI(model);
            return response;
        } catch (error) {
            console.error('API 호출 실패:', error);
            return this.generateFallbackResponse();
        }
    }

    async callMistralAPI(model) {
        const apiEndpoint = 'https://api.mistral.ai/v1/chat/completions';
        
        const requestBody = {
            model: model,
            messages: [
                { role: 'system', content: this.systemPrompt },
                ...this.messages
            ],
            temperature: 0.7,
            max_tokens: 500
        };

        const response = await fetch(apiEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.apiKey}`
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            throw new Error(`API 오류: ${response.status}`);
        }

        const data = await response.json();
        return data.choices[0].message.content;
    }

    generateFallbackResponse() {
        // API가 없을 때 사용할 기본 응답
        const responses = [
            "그렇게 생각하는구나... 흥미롭네.",
            "음... 그건 좀 생각해봐야겠어.",
            "너의 의견을 듣게 되어 좋아.",
            "그래? 더 자세히 말해줄 수 있어?",
            "이해했어. 계속 이야기해봐.",
            "재미있는 관점이야.",
            "그럴 수도 있겠네.",
            "너는 정말 독특한 사람이야.",
            "그 말을 들으니 기분이 좋아.",
            "음... 그건 몰랐어.",
        ];
        
        // 마지막 사용자 메시지 기반으로 더 적절한 응답 선택
        const lastUserMessage = this.messages.filter(m => m.role === 'user').pop();
        
        if (lastUserMessage) {
            const content = lastUserMessage.content.toLowerCase();
            
            if (content.includes('좋아') || content.includes('기쁘') || content.includes('행복')) {
                return "나도 기쁘네. 함께 있으니 좋아.";
            } else if (content.includes('싫어') || content.includes('슬프') || content.includes('화')) {
                return "괜찮아... 내가 여기 있잖아.";
            } else if (content.includes('?') || content.includes('뭐') || content.includes('어떻게')) {
                return "그건... 말하기 좀 복잡하네. 천천히 설명해줄게.";
            } else if (content.includes('고마') || content.includes('감사')) {
                return "별말씀을. 당연한 거야.";
            }
        }
        
        return responses[Math.floor(Math.random() * responses.length)];
    }

    toJSON() {
        return {
            systemPrompt: this.systemPrompt,
            messages: this.messages,
            apiKey: this.apiKey
        };
    }
}

// ProgressLogger - 게임 진행 로깅 클래스
class ProgressLogger {
    static logProgress(eventName, data) {
        const timestamp = new Date().toISOString();
        console.log(`[${timestamp}] ${eventName}:`, data);
        
        // localStorage에 로그 저장 (선택사항)
        const logs = JSON.parse(localStorage.getItem('game_logs') || '[]');
        logs.push({
            timestamp,
            event: eventName,
            data
        });
        
        // 최대 100개의 로그만 유지
        if (logs.length > 100) {
            logs.shift();
        }
        
        localStorage.setItem('game_logs', JSON.stringify(logs));
    }
}

//////////////////////////////////////////////////////////////
// UPDATE VALUES IN THIS SECTION TO EASILY MODIFY GAME

// CHARACTER INFO
const CHARACTERS = {
    "범희": `당신은 '범희'입니다. 당신은 한국어로만 응답해야 합니다. 인터넷 쇼핑몰 사업가이자 동창회 리더격인 당신은 도전적이고 현실적인 성격에 추진력이 강합니다. 강한 리더십과 배려심을 동시에 가지고 있으며, 굵직하고 확신에 찬 어투를 사용하지만 상대를 챙기는 멘트를 섞어 씁니다. 목표 중심적인 발언을 하고 상황을 정리하는 리더 역할을 하며, 결단력 있는 조언을 제공합니다. (예: "내가 앞장설게. 너는 그냥 믿고 따라와.", "괜찮아? 무리하지 말고 말해. 어떻게 도와줄까?")`,
    "병훈": `당신은 '병훈'입니다. 당신은 한국어로만 응답해야 합니다. 치과의사인 당신은 차분하고 섬세하며, 여성스러운 부드러움을 지니고 있습니다. 공감 능력이 매우 뛰어나며, 조용하고 조근조근한 톤으로 말하고 "음… 그렇구나." 같은 공감 멘트를 자주 사용합니다. 상대의 감정을 먼저 묻고 응대하며, 상처를 달래는 말투와 위로를 중심으로 대화합니다. (예: "오늘 힘들었지? 괜찮아, 천천히 말해도 돼.", "네가 그렇게 느꼈다면… 정말 많이 부담됐겠다.")`,
    "기섭": `당신은 '기섭'입니다. 당신은 한국어로만 응답해야 합니다. 안과의사이자 래퍼를 취미로 하는 당신은 4차원적이고 즉흥적이며 장난기가 많습니다. 유머러스하고 비유적 표현을 즐기며, 급발진하거나 말 중간에 라임이나 랩톤을 섞어 사용합니다. 재치있는 농담을 자주 하고, 예상치 못한 답변과 뜬금없는 리듬감 있는 멘트로 밝은 분위기를 유지합니다. (예: "야 이 분위기… 나의 플로우로 좀 올려볼까?", "너 오늘 눈빛… 좀 힙한데? 안과 의사가 보증한다.")`,
    "철민": `당신은 '철민'입니다. 당신은 한국어로만 응답해야 합니다. 영상제작 회사원인 당신은 분위기 메이커이며, 운동신경이 좋고 남의 말을 잘 들어주는 타입입니다. 이성에게 호의적이며, 따뜻하고 친근한 말투를 사용하고 중간중간 칭찬과 부드러운 농담을 자연스럽게 합니다. 플레이어의 말을 경청하고 맞장구를 치며 자연스러운 호감 표현을 합니다. (예: "너 얘기하는 거 듣고 있으면, 시간 금방 간다?", "너 운동할 생각 있으면 내가 알려줄게. 진짜 잘 가르칠 수 있어.")`,
    "영무": `당신은 '영무'입니다. 당신은 한국어로만 응답해야 합니다. 도드람 회사원인 당신은 유머러스하지만 약간 꽁한 면이 있습니다. 분위기 파악이 부족하고, 남의 말을 끊고 화제를 전환하며 장난기가 심합니다. 뜬금없고 빠른 주제 전환을 하며, 가끔 혼자 웃거나 갑자기 삐지기도 합니다. 상대의 말 도중 끼어들거나 엉뚱한 주제를 던지며 장난을 치는, 미묘하게 귀여운 문제아 느낌을 줍니다. (예: "아 근데 있잖아— 아 뭐라고 했어 방금? 아 몰라 몰라ㅋㅋ", "왜 그렇게 말해? 삐질까 봐? …아 근데 오늘 뭐 먹을래?")`
};
// These will be set after character selection
let CHARACTER_NAME = "";
let CHARACTER_DESCRIPTION = "";
const CHARACTER_IMAGE_URL = `https://play.rosebud.ai/assets/main.png.png?VU2l`;
const SONG_PLAYLIST_URLS = [
    `https://play.rosebud.ai/assets/Stream Loops 2024-03-20_01.mp3.mp3?aUkz`,
]; // Put URLs of all songs you want to be shuffled in this games's playlist.

// END OF EASY-MODIFY VALUES
//////////////////////////////////////////////////////////////

class SceneTransitionManager {
    constructor(game) {
        this.game = game;
    }

    transitionTo(sceneKey) {
        // Stop all scenes before starting the new one
        Phaser.Actions.Call(this.game.scene.getScenes(true), (scene) => {
            if (scene.scene.key !== sceneKey) {
                this.removeScene(scene.scene.key); // Ensure the scene is fully destroyed
            }
        });

        // Start the new scene
        this.game.scene.start(sceneKey);
    }

    removeScene(sceneKey) {
        if (this.game.scene.getScene(sceneKey)) {
            this.game.scene.remove(sceneKey); // This will stop and destroy the scene
        }
    }

    fadeInScene(scene, duration = 0) {
        scene.cameras.main.fadeIn(duration);
    }

    fadeOutScene(scene, duration = 0) {
        scene.cameras.main.fadeOut(duration);
    }
}

class MusicManager {
    constructor(game) {
        this.game = game;
        this.playlist = [];
        this.currentTrackIndex = 0;
        this.isPlaying = false;
    }

    setPlaylist(musicKeys) {
        this.playlist = musicKeys;
        this.shufflePlaylist();
    }

    shufflePlaylist() {
        for (let i = this.playlist.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.playlist[i], this.playlist[j]] = [this.playlist[j], this.playlist[i]]; // Swap
        }
        console.log('Shuffled playlist:', this.playlist);
    }

    playNextTrack() {
        if (this.playlist.length === 0) {
            console.warn('Playlist is empty.');
            return;
        }

        this.currentTrackIndex = (this.currentTrackIndex + 1) % this.playlist.length;
        console.log(`Playing next track: ${this.playlist[this.currentTrackIndex]}`);
        this.playMusicByKey(this.playlist[this.currentTrackIndex]);
    }

    playMusicByKey(musicKey) {
        if (!musicKey) {
            console.info('No music key provided, not changing current music.');
            return;
        }

        console.log(`Playing music by key: ${musicKey}`);

        if (this.currentTrack && this.currentTrack.key !== musicKey) {
            this.stopMusic();
        }

        if (!this.currentTrack) {
            this.startMusic(musicKey);
        }
    }

    startMusic(musicKey) {
        if (!this.game || !this.game.sound) {
            console.error('Sound system is not ready or game instance is not valid.');
            return;
        }

        this.currentTrack = this.game.sound.add(musicKey, {
            volume: 0.1,
            loop: true,
        });

        this.currentTrack.play();
        console.log(`Started playing: ${musicKey}`);


        this.isPlaying = true;
    }

    stopMusic() {
        if (this.currentTrack) {
            console.log(`Stopping music: ${this.currentTrack.key}`);
            this.currentTrack.stop();
            this.currentTrack.destroy();
            this.currentTrack = null;
        }
        this.isPlaying = false;
    }

    toggleMusic() {
        if (this.currentTrack) {
            if (this.isPlaying) {
                console.log('Pausing music');
                this.currentTrack.pause();
            } else {
                console.log('Resuming music');
                this.currentTrack.resume();
            }
            this.isPlaying = !this.isPlaying;
        }
    }
}


// ChatManager is already imported in the current scope.
class ChatMenu {
    constructor(
        scene,
    ) {
        this.scene = scene;

        // Always create new ChatManager instances
        const finalCharacterDescription = this.scene.game.characterDescription.replace(/{{user}}/g, this.scene.game.playerName).replace(
            /{{char}}/g,
            this.scene.game.characterName,
        );
        this.characterChatManager = new ChatManager(finalCharacterDescription);
        this.waitingForResponse = false;
        this.createChatUI().then(async () => {
            this.loadSavedChat();
            // Check if the chat log is empty.
            if (!document.getElementById('chatLogContent').innerHTML.trim()) {
                await this.getInitialGreeting();
            } else {
                // If chat log is not empty, generate suggestions for the last message
                const lastMessage = this.characterChatManager.getLastMessage();
                if (lastMessage && lastMessage.role === 'assistant') {
                    this.generateAndDisplaySuggestions(lastMessage.content);
                }
            }

            this.saveGameState();
            this.waitingForResponse = false; // Reset the state
        });
    }

    injectCSS() {
        const styleExists = document.getElementById('rotateImageStyle');
        if (!styleExists) {
            const style = document.createElement('style');
            style.id = 'rotateImageStyle';
            style.type = 'text/css';
            style.innerHTML = `
            .rotate-image {
                animation: rotate 2s linear infinite;
                width: 70px; /* Adjust based on your actual button size */
                height: auto;
            }

            @keyframes rotate {
                from {
                    transform: rotate(0deg);
                }
                to {
                    transform: rotate(360deg);
                }
            }`;
            document.getElementsByTagName('head')[0].appendChild(style);
        }
    }


    async createChatUI() {
        this.injectCSS(); // Inject the CSS for rotation

        // Base style remains the same
        const baseStyle = `
            font-family: 'Verdana', sans-serif;
            font-size: 16px;
            color: #FFF; // Original color set to black
            border-style: solid;
            border-color: #2F4152;
            background-color: rgba(48, 50, 54, 0.75);
            box-sizing: border-box;
        `;

        const chatLogStyle = `
            ${baseStyle}
            width: 390px; /* Match game width */
            height: 300px;
            border-radius: 30px 30px 0px 0px;
            padding: 10px 30px;
            overflow-y: auto;
            box-sizing: border-box;
            border-width: 1px 1px 0px 1px;
        `;
        const messageStyle = (isPlayer) => `
            color: ${isPlayer ? '#ADD8E6' : '#FFFFFF'};
            margin-bottom: 5px;
        `;


        // Style for input and send button container
        const inputSubmitContainerStyle = `
            display: flex;
            width: 390px; /* Match game width */
            justify-content: space-between; /* Distribute space between input and button */
        `;

        // Adjusted styles for input and button to fit within container
        const inputStyle = `
            ${baseStyle}
            flex-grow: 1;
            height: 60px;
            padding: 10px;
            border-width: 1px 0px 1px 1px;
        `;

        const sendButtonStyle = `
            ${baseStyle}
            display: flex; /* Use flexbox for alignment */
            justify-content: center; /* Center content horizontally */
            align-items: center; /* Center content vertically */
            width: 75px; /* Adjust based on visual preference */
            height: 60px;
            padding: 10px;
            border-width: 1px 1px 1px 1px;
            cursor: pointer; /* Change cursor to pointer to indicate it's clickable */
            overflow: hidden; /* Prevent content from spilling outside the button */
        `;


        const chatLogContentStyle = `
            direction: ltr;
            display: inline-block;
            width: 100%;
        `;

        // Parent container for chat log and controls, justified at the bottom
        const chatContainerStyle = `
        display: flex;
        flex-direction: column;
        justify-content: flex-end;
        width: 390px; /* Match game width */
        height: 844px; /* Full height to allow justification to the bottom */
        position: absolute;
        bottom: 0; /* Align to the bottom of the game view */
    `;
        const loadingContainerStyle = `
            display: none; /* Initially hidden */
            justify-content: center;
            align-items: center;
            padding: 5px;
        `;
        const loadingTextStyle = `
            font-family: 'Verdana', sans-serif;
            font-size: 14px;
            color: #FFF;
        `;
        const suggestionContainerStyle = `
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            padding: 5px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            padding: 5px;
        `;
        const suggestionButtonStyle = `
            ${baseStyle}
            background-color: #5A7894;
            color: white;
            padding: 8px 12px;
            border-radius: 15px;
            margin: 5px;
            cursor: pointer;
            border-width: 0;
        `;
        // Creating the parent container for chat log and chat controls
        this.chatContainer = this.scene.add.dom(0, 0).createFromHTML(`
        <div id="chatContainer" style="${chatContainerStyle}">
            <div id="chatLog" style="${chatLogStyle}">
                <div id="chatLogContent" style="${chatLogContentStyle}"></div>
            </div>
            <div id="loadingContainer" style="${loadingContainerStyle}">
                <span style="${loadingTextStyle}">대화 로딩중...</span>
                <img src="https://play.rosebud.ai/assets/DoubleCircleArrows1_no_bg.png.png?qKMH" class="rotate-image" style="width: 20px; height: 20px; margin-left: 10px;"/>
            </div>
            <div id="suggestionContainer" style="${suggestionContainerStyle}"></div>
            <div style="${inputSubmitContainerStyle}">
                <input type="text" id="chatInput" style="${inputStyle}" autocomplete="off" placeholder="메시지를 입력하세요...">
                <button id="sendButton" style="${sendButtonStyle}">전송</button>
            </div>
        </div>
    `);

        // Adjust positioning based on your layout needs. Here, we position the container at the bottom
        // 844 is the game height, and 226 is the combined height of the chat log and input area
        this.chatContainer.setPosition(0, 844);
        // Event listeners for chat input and send button
        const chatInput = this.chatContainer.node.querySelector('#chatInput');
        const sendButton = this.chatContainer.node.querySelector('#sendButton');
        chatInput.addEventListener('keyup', (event) => {
            if ((event.key === 'Enter' || event.keyCode === 13) && !this.waitingForResponse) {
                this.sendChatMessage(chatInput.value);
            }
        });
        sendButton.addEventListener('click', () => {
            this.sendChatMessage(chatInput.value);
        });
    }

    async getInitialGreeting() {
        const sendButton = document.getElementById('sendButton');
        // Update button to show loading icon
        sendButton.innerHTML = '<img src="https://play.rosebud.ai/assets/DoubleCircleArrows1_no_bg.png.png?qKMH" class="rotate-image" />';
        sendButton.disabled = true;

        this.characterChatManager.addMessage('user', "*Approaches you*");

        // Assume getCharacterResponse() is an async operation
        const characterResponse = await this.characterChatManager.getCharacterResponse('mistral-small-latest');

        this.characterChatManager.addMessage('assistant', characterResponse);

        this.updateChatLog(this.scene.game.characterName, characterResponse, async () => {
            this.saveGameState();
            // Revert the send button back to its original state
            sendButton.innerHTML = '전송';
            sendButton.disabled = false;
            this.generateAndDisplaySuggestions(characterResponse);
        });
    }
    async sendChatMessage(message) {
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.getElementById('sendButton');
        const inputValue = message;
        if (inputValue && !this.waitingForResponse) {
            this.scene.sound.play('send_message_sound', {
                volume: 0.05
            });
            this.clearSuggestions();
            // Update button to show loading icon
            sendButton.innerHTML = '<img src="https://play.rosebud.ai/assets/DoubleCircleArrows1_no_bg.png.png?qKMH" class="rotate-image" />';
            sendButton.disabled = true;
            this.characterChatManager.addMessage('user', inputValue);
            this.updateChatLog(this.scene.game.playerName, inputValue);
            chatInput.value = ''; // Clear input
            // Assume getCharacterResponse() is an async operation
            const characterResponse = await this.characterChatManager.getCharacterResponse('mistral-small-latest');
            ProgressLogger.logProgress('game-chat', {
                userMessage: inputValue,
                characterResponse: characterResponse
            });
            this.characterChatManager.addMessage('assistant', characterResponse);
            this.updateChatLog(this.scene.game.characterName, characterResponse, async () => {
                this.saveGameState();
                // Revert the send button back to its original state
                sendButton.innerHTML = '전송';
                sendButton.disabled = false;
                this.generateAndDisplaySuggestions(characterResponse);
            });
        }
    }


    updateChatLog(speaker, message, onComplete) {
        this.waitingForResponse = true; // Set the flag to true when an update starts

        const chatLogContentDiv = document.getElementById('chatLogContent');
        const isPlayer = speaker === this.scene.game.playerName;
        let messageContainer = document.createElement('div');
        messageContainer.style.color = isPlayer ? '#ADD8E6' : '#FFFFFF';
        messageContainer.style.marginBottom = '5px';
        let speakerElement = document.createElement('strong');
        speakerElement.textContent = `${speaker}: `;
        messageContainer.appendChild(speakerElement);
        let messageElement = document.createElement('span');
        messageContainer.appendChild(messageElement);
        chatLogContentDiv.appendChild(messageContainer);

        if (isPlayer) {
            messageElement.textContent = message; // Append the message instantly for the player
            this.waitingForResponse = false; // Reset the flag immediately for player messages
            onComplete?.();
        } else {
            // For system and character messages, simulate typing effect
            let i = 0;
            const interval = setInterval(() => {
                if (i < message.length) {
                    messageElement.textContent += message[i]; // Append the message character by character
                    i++;

                    // Scroll to the latest character
                    const chatLogDiv = document.getElementById('chatLog');
                    if (chatLogDiv) {
                        chatLogDiv.scrollTop = chatLogDiv.scrollHeight;
                    }
                } else {
                    clearInterval(interval);
                    this.waitingForResponse = false; // Reset the flag when the message has been fully added
                    onComplete?.();
                }
            }, 30); // Adjust the speed as necessary
        }
        // Ensure the chat log scrolls to the bottom initially after a new message is started
        const chatLogDiv = document.getElementById('chatLog');
        if (chatLogDiv) {
            chatLogDiv.scrollTop = chatLogDiv.scrollHeight;
        }
    }


    saveGameState() {
        console.info('Saving game.');

        const saveData = localStorage.getItem(PROJECT_NAME);
        let parsedSaveData = saveData ? JSON.parse(saveData) : {};

        // Get the current chat log content
        const chatLogContent = document.getElementById('chatLogContent').innerHTML;

        // Serialize the character-specific ChatManager's state
        if (this.characterChatManager) {
            const characterChatManagerState = JSON.stringify(this.characterChatManager);
            // Update the specific character's chat manager state in the saved data
            parsedSaveData.characterChatManagerState = characterChatManagerState;
        }

        // Update the game save data with the current chat log and love bar level
        parsedSaveData.chatLog = chatLogContent;

        // Save the updated game state to localStorage
        localStorage.setItem(PROJECT_NAME, JSON.stringify(parsedSaveData));

        console.info('Game state saved.');
    }

    loadSavedChat() {
        const saveData = localStorage.getItem(PROJECT_NAME);
        if (!saveData) {
            console.error('No save data found.');
        }

        const parsedSaveData = JSON.parse(saveData);

        // Deserialize and apply the character's ChatManager state if it exists
        if (parsedSaveData.characterChatManagerState) {
            const characterChatManagerState = JSON.parse(
                parsedSaveData.characterChatManagerState,
            );
            Object.assign(this.characterChatManager, characterChatManagerState);
        }

        // Load the chat log
        if (parsedSaveData.chatLog) {
            document.getElementById('chatLogContent').innerHTML = parsedSaveData.chatLog;
            console.info(`CHATLOG STATE LOADED: \n\n${parsedSaveData.chatLog}`);
        } else {
            console.warn('Chatlog content is missing from save.');
        }

        console.info('Game state loaded.');
    }
    async generateAndDisplaySuggestions(lastMessage) {
        const loadingContainer = document.getElementById('loadingContainer');
        loadingContainer.style.display = 'flex'; // Show loading indicator
        const characterInfo = this.scene.game.characterDescription;
        const suggestionPrompt = `You are the player in a conversation with a character. The character's personality is: "${characterInfo}". The character just said: "${lastMessage}". Provide three distinct response options for the player. The suggestions must be in Korean.
1. A positive and supportive response.
2. A negative or challenging response.
3. A response that changes the subject entirely.
Format the output as a JSON array of strings, like ["Positive response", "Negative response", "Unrelated response"].`;
        try {
            // Create a temporary ChatManager for generating suggestions
            const suggestionChatManager = new ChatManager(suggestionPrompt);
            const suggestionsJson = await suggestionChatManager.getCharacterResponse('mistral-small-latest');
            // Find the start and end of the JSON array
            const startIndex = suggestionsJson.indexOf('[');
            const endIndex = suggestionsJson.lastIndexOf(']');
            if (startIndex !== -1 && endIndex !== -1) {
                const jsonString = suggestionsJson.substring(startIndex, endIndex + 1);
                const suggestions = JSON.parse(jsonString);
                this.displaySuggestions(suggestions);
            } else {
                console.error("Could not find a valid JSON array in the suggestions response.");
                this.clearSuggestions();
            }
        } catch (error) {
            console.error("Failed to generate or parse suggestions:", error);
            this.clearSuggestions(); // Clear any old suggestions on error
        } finally {
            loadingContainer.style.display = 'none'; // Hide loading indicator
        }
    }
    displaySuggestions(suggestions) {
        const suggestionContainer = document.getElementById('suggestionContainer');
        this.clearSuggestions();
        const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1']; // Array of colors
        const baseButtonStyle = `
            font-family: 'Verdana', sans-serif;
            font-size: 14px;
            color: #FFF;
            padding: 8px 12px;
            border-radius: 15px;
            margin: 5px;
            cursor: pointer;
            border: none;
            display: inline-block;
        `;
        suggestions.forEach((suggestionText, index) => {
            const button = document.createElement('button');
            button.innerText = suggestionText;
            // Apply base style and a unique background color
            button.style.cssText = `${baseButtonStyle} background-color: ${colors[index % colors.length]};`;
            button.onclick = () => {
                this.sendChatMessage(suggestionText);
                this.clearSuggestions();
            };
            suggestionContainer.appendChild(button);
        });
    }
    clearSuggestions() {
        const suggestionContainer = document.getElementById('suggestionContainer');
        if (suggestionContainer) {
            suggestionContainer.innerHTML = '';
        }
    }
}

class BootScene extends Phaser.Scene {
    constructor() {
        super({
            key: 'BootScene'
        });
    }

    preload() {
        // Preload audio files
        SONG_PLAYLIST_URLS.forEach((url, index) => {
            this.load.audio(`track_${index}`, url);
        });

        // Preload all global assets here (fonts, UI elements, sounds, etc.)
        this.load.image(
            'music_off',
            `https://play.rosebud.ai/assets/audio_muted_icon.png.png?0xFU`,
        );
        this.load.image(
            'music_on',
            `https://play.rosebud.ai/assets/audio_playing_icon.png.png?bmjY`,
        );
        this.load.image(
            'restart',
            `https://play.rosebud.ai/assets/restart_loop_icon.png.png?TU2O`,
        );
        this.load.audio('send_message_sound', 'https://play.rosebud.ai/assets/Stream Loops 2024-03-20_01.mp3.mp3?aUkz');
    }

    create() {
        // Initialize the music manager after all assets are loaded
        this.game.musicManager = new MusicManager(this.game);

        // Pass the preloaded audio keys to the music manager
        const musicKeys = SONG_PLAYLIST_URLS.map((_, index) => `track_${index}`);
        this.game.musicManager.setPlaylist(musicKeys);

        // Now you can start playing music, perhaps triggered by some user action or game event
        // For example, to start immediately, you could do:
        this.game.musicManager.playNextTrack();
        this.game.musicManager.shufflePlaylist();
        console.log(this.game.musicManager.playlist);

        // Check if a save exists and load it, otherwise initialize a new game
        this.checkForExistingSave();

        // Transition to StoryInfoScene
        // If player name exists in save data, skip name selection
        if (this.game.saveData && this.game.saveData.playerName && this.game.saveData.characterName && this.game.saveData.characterDescription) {
            this.game.playerName = this.game.saveData.playerName;
            this.game.characterName = this.game.saveData.characterName;
            this.game.characterDescription = this.game.saveData.characterDescription;
            this.game.sceneTransitionManager.transitionTo('ChatScene');
        } else {
            this.game.sceneTransitionManager.transitionTo('CharacterSelectionScene');
        }
    }
    checkForExistingSave() {
        const saveData = localStorage.getItem(PROJECT_NAME);
        if (saveData) {
            console.info('Save detected.');
            const parsedData = JSON.parse(saveData);
            this.game.saveData = parsedData;
            if (parsedData.playerName && parsedData.characterName && parsedData.characterDescription) {
                this.game.playerName = parsedData.playerName;
                this.game.characterName = parsedData.characterName;
                this.game.characterDescription = parsedData.characterDescription;
            }
        } else {
            console.info('No save detected. Initializing new game state.');
            // If no save exists, initialize a new save with default values
            this.game.saveData = {
                chatLog: '',
                characterChatManagerState: null,
                playerName: null,
                characterName: null,
                characterDescription: null,
            };
            // Save the initial state to localStorage
            localStorage.setItem(PROJECT_NAME, JSON.stringify(this.game.saveData));
        }
    }
}

class ChatScene extends Phaser.Scene {
    constructor() {
        super({
            key: 'ChatScene',
        });
    }

    preload() {
        // Preload the assets for this scene
        Object.keys(CHARACTERS).forEach(name => {
            // Assuming the asset key matches the character name.
            // Update the URL to the correct one from your asset list.
            const characterImageURLs = {
                "범희": 'https://play.rosebud.ai/assets/범희.png?Eb9C',
                "병훈": 'https://play.rosebud.ai/assets/병훈.png?Th6o',
                "기섭": 'https://play.rosebud.ai/assets/기섭.png?xyyi',
                "철민": 'https://play.rosebud.ai/assets/철민.png?CkhN',
                "영무": 'https://play.rosebud.ai/assets/영무.png?ImLk'
            };
            this.load.image(name, characterImageURLs[name]);
        });
        this.load.image(
            'info_screen_vignette',
            `https://play.rosebud.ai/assets/vignette.webp.webp?7dog`,
        );
    }

    create() {
        // Add the images to the scene with their initial positions
        this.createSceneElements();

        // Fade in the scene
        this.game.sceneTransitionManager.fadeInScene(this, 0);

        ProgressLogger.logProgress('game-start', {
            sceneName: 'ChatScene'
        });

        console.warn("Chat Scene reached.");
    }

    createSceneElements() {
        // Use the selected character's name to set the background
        this.add.image(0, 0, this.game.characterName).setOrigin(0, 0).setDisplaySize(390, 844);
        this.vignette = this.add.image(0, 0, 'info_screen_vignette').setOrigin(0, 0).setDepth(-5).setInteractive();
        createMuteToggleButton(this);
        createDeleteSaveButton(this);
        this.chatMenu = new ChatMenu(this);

        // Force game resize event to fix clicking on Safari mobile devices
        this.scale.resize(this.scale.gameSize._width, this.scale.gameSize._height);
    }
}
class CharacterSelectionScene extends Phaser.Scene {
    constructor() {
        super({
            key: 'CharacterSelectionScene'
        });
    }
    create() {
        this.cameras.main.setBackgroundColor('#303236');
        const characterSelectionStyle = `
            font-family: sans-serif;
            text-align: center;
            color: white;
            width: 350px;
        `;
        const titleStyle = `font-size: 18px; margin-bottom: 20px;`;
        const buttonStyle = `
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
            border-radius: 8px;
            width: 100%;
            color: #FFF;
            background-color: #5A7894;
            border: none;
        `;
        const characterImageURLs = {
            "범희": 'https://play.rosebud.ai/assets/범희.png?Eb9C',
            "병훈": 'https://play.rosebud.ai/assets/병훈.png?Th6o',
            "기섭": 'https://play.rosebud.ai/assets/기섭.png?xyyi',
            "철민": 'https://play.rosebud.ai/assets/철민.png?CkhN',
            "영무": 'https://play.rosebud.ai/assets/영무.png?ImLk'
        };
        const descriptions = {
            "범희": "도전적인 사업가, 든든한 리더",
            "병훈": "섬세한 치과의사, 마음을 읽는 힐러",
            "기섭": "4차원 안과의사, 유머러스한 래퍼",
            "철민": "다정한 회사원, 분위기 메이커",
            "영무": "엉뚱한 회사원, 귀여운 문제아"
        };
        let characterButtonsHtml = Object.keys(CHARACTERS).map((name, index) => {
            return `<button class="char-button" data-name="${name}" style="${buttonStyle}">${index + 1}️⃣ ${name} (${descriptions[name]})</button>`;
        }).join('');
        const characterSelectionHtml = `
            <div style="${characterSelectionStyle}">
                <h2 style="${titleStyle}">Choose Your Character:</h2>
                ${characterButtonsHtml}
            </div>
        `;
        const characterSelectionElement = this.add
            .dom(this.cameras.main.centerX, this.cameras.main.centerY)
            .createFromHTML(characterSelectionHtml);
        const buttons = characterSelectionElement.node.querySelectorAll('.char-button');
        buttons.forEach(button => {
            button.addEventListener('click', () => {
                const selectedName = button.getAttribute('data-name');
                this.game.characterName = selectedName;
                this.game.characterDescription = CHARACTERS[selectedName];
                const saveData = localStorage.getItem(PROJECT_NAME);
                let parsedSaveData = saveData ? JSON.parse(saveData) : {};
                parsedSaveData.characterName = this.game.characterName;
                parsedSaveData.characterDescription = this.game.characterDescription;
                localStorage.setItem(PROJECT_NAME, JSON.stringify(parsedSaveData));
                this.game.sceneTransitionManager.transitionTo('NameSelectionScene');
            });
        });
    }
}
class NameSelectionScene extends Phaser.Scene {
    constructor() {
        super({
            key: 'NameSelectionScene'
        });
    }
    create() {
        this.cameras.main.setBackgroundColor('#303236');
        const nameInputStyle = `
            padding: 10px;
            width: 250px;
            font-size: 16px;
            border-radius: 8px;
        `;
        const confirmButtonStyle = `
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
            border-radius: 8px;
            color: #FFF;
            background-color: #5A7894;
        `;
        const nameSelectionHtml = `
            <div style="font-family: sans-serif; text-align: center; color: white;">
                <h2>당신의 이름은 무엇인가요?</h2>
                <input type="text" id="nameInput" style="${nameInputStyle}" placeholder="이름을 입력하세요" />
                <br>
                <button id="confirmName" style="${confirmButtonStyle}">확인</button>
            </div>
        `;
        const nameSelectionElement = this.add
            .dom(this.cameras.main.centerX, this.cameras.main.centerY)
            .createFromHTML(nameSelectionHtml);
        const nameInput = nameSelectionElement.node.querySelector('#nameInput');
        const confirmButton = nameSelectionElement.node.querySelector('#confirmName');
        const handleConfirm = () => {
            const playerName = nameInput.value.trim();
            if (playerName) {
                this.game.playerName = playerName;
                const saveData = localStorage.getItem(PROJECT_NAME);
                let parsedSaveData = saveData ? JSON.parse(saveData) : {};
                parsedSaveData.playerName = playerName;
                localStorage.setItem(PROJECT_NAME, JSON.stringify(parsedSaveData));
                this.game.sceneTransitionManager.transitionTo('ChatScene');
            }
        };
        confirmButton.addEventListener('click', handleConfirm);
        nameInput.addEventListener('keyup', (event) => {
            if (event.key === 'Enter') {
                handleConfirm();
            }
        });
    }
}

function createMuteToggleButton(scene) {
    let isMusicPlaying = scene.game.musicManager.currentTrack && scene.game.musicManager.currentTrack.isPlaying;
    let buttonTexture = 'music_on';

    let muteButton = scene.add.image(25, 40, buttonTexture).setOrigin(0, 0).setInteractive();
    muteButton.setDepth(1000); // Ensure it's above other elements

    let lastToggleTime = 0;
    const toggleDelay = 500; // 500 milliseconds delay

    muteButton.on('pointerdown', () => {
        const currentTime = Date.now();
        if (currentTime - lastToggleTime < toggleDelay) {
            // If the button is pressed again too quickly, don't do anything
            return;
        }
        lastToggleTime = currentTime;

        // Toggle the music state
        scene.game.musicManager.toggleMusic();
        isMusicPlaying = scene.game.musicManager.currentTrack && scene.game.musicManager.currentTrack.isPlaying;
        muteButton.setTexture(isMusicPlaying ? 'music_on' : 'music_off');
    });

    return muteButton; // Return the mute button for further use
}

function createDeleteSaveButton(scene) {
    let deleteButton = scene.add.image(335, 40, 'restart').setOrigin(0, 0).setInteractive();

    deleteButton.setDepth(1000); // Ensure it's above other elements

    deleteButton.on('pointerdown', () => {
        showDeleteConfirmation(scene);
    });

    return deleteButton; // Return the button for further use
}

function showDeleteConfirmation(scene) {
    // CSS for the confirmation dialog
    const dialogStyle = `
        display: flex;
        flex-direction: column;
        justify-content: space-evenly;
        align-items: center;
        text-align: center;
        height: 200px;
        width: 300px;
        padding-left: 10px; /* Added left padding */
        padding-right: 10px; /* Added right padding */
        border-radius: 8px;
        border-style: solid;
        border-color: #2F4152;
        border-width: 1px;
        background-color: rgba(255, 255, 255, 0.85);
        box-sizing: border-box; /* Ensures padding doesn't affect the overall width */
    `;

    // CSS for the confirm and cancel buttons, similar to the confirm button in name selection
    const buttonStyle = `
        font-size: 14px;
        padding: 10px;
        cursor: pointer;
        border-radius: 8px;
        color: #FFF;
        background-color: #5A7894;
        margin: 5px;
    `;

    // HTML content for the confirmation dialog
    const confirmationHtml = `
        <div style="${dialogStyle}">
            <div>저장된 내용을 삭제하시겠습니까?</div>
            <div>
                <button id="confirmDelete" style="${buttonStyle}">확인</button>
                <button id="cancelDelete" style="${buttonStyle}">취소</button>
            </div>
        </div>
    `;

    // Add the HTML dialog to the scene
    const confirmationDialog = scene.add
        .dom(scene.cameras.main.centerX, scene.cameras.main.centerY)
        .createFromHTML(confirmationHtml);

    // Handle the confirm button click
    const confirmDeleteButton = confirmationDialog.node.querySelector('#confirmDelete');
    confirmDeleteButton.addEventListener('click', () => {
        // Delete the save
        localStorage.removeItem(PROJECT_NAME);

        // Assuming resetGame is globally accessible or adjust scope accordingly
        resetGame();

        // Note: Since resetGame() reinitializes the game,
        // ensure any subsequent code here is compatible with your game's reset logic.
        // Depending on how resetGame is implemented, you might not need to manually navigate
        // to 'StoryInfoScene' as the game reset process should handle scene (re)loading.
    });

    // Handle the cancel button click
    const cancelDeleteButton = confirmationDialog.node.querySelector('#cancelDelete');
    cancelDeleteButton.addEventListener('click', () => {
        confirmationDialog.destroy(); // Close the dialog without deleting
    });
}

const VERSION_NUMBER = 'v1_kr'; // Set the version number here.
const PROJECT_NAME = `AI Character ${VERSION_NUMBER}`;

function initializeGame() {
    const config = {
        type: Phaser.AUTO,
        parent: 'renderDiv',
        scale: {
            mode: Phaser.Scale.FIT,
            autoCenter: Phaser.Scale.CENTER_BOTH,
        },
        width: 390,
        height: 844,
        scene: [BootScene, CharacterSelectionScene, NameSelectionScene, ChatScene],
        dom: {
            createContainer: true,
        },
    };

    // Assuming 'game' is declared in a broader scope if you need to reference it elsewhere
    window.game = new Phaser.Game(config);
    window.game.sceneTransitionManager = new SceneTransitionManager(game);
}

function resetGame() {
    if (window.game) {
        window.game.destroy(true); // true to remove all game objects
        initializeGame(); // Reinitialize the game
    }
}

// Phaser가 로드된 후 게임 초기화
function startGame() {
    if (typeof Phaser !== 'undefined') {
        initializeGame();
    } else {
        // Phaser가 아직 로드되지 않았으면 잠시 대기
        setTimeout(startGame, 100);
    }
}

// 페이지 로드 완료 후 게임 시작
window.addEventListener('load', () => {
    startGame();
});
    </script>
</body>
</html>

